session = dy_import_module("session.r2py")
advertisepipe = dy_import_module("advertisepipe.r2py")
affix_stack = dy_import_module("affix_stack.r2py")
dy_import_module_symbols("tcp_relay_common_lib.r2py")
canilisten = dy_import_module("canilisten.r2py")
time = dy_import_module("time.r2py")

SLEEP_TIME = 0.001
MAX_BUFFER_LEN = 1400

buffer = 4   # main and advertise thread, and two spares
available_threads = getresources()[0]['events'] - buffer
MAX_CLIENTS_PER_SERVER = 5
MAX_SERVERS = max(1, int(available_threads/MAX_CLIENTS_PER_SERVER))

INFO_MSG = 1
ERR_MSG = 2
DEBUG_MSG = 3

registered_server = {}
register_lock = createlock()


def logmsg(message, msg_type):

  header = "[%.4f] " % time.time_getunixtime()

  if msg_type == INFO_MSG:
    header += "INFO: "
  elif msg_type == ERR_MSG:
    header += "ERROR: "
  elif msg_type == DEBUG_MSG:
    header += "DEBUG: "

  log(header + message + '\n')
  
  
    
# ====================================================
# TCP NAT Forwarder - Common Entry Point.
# ====================================================
def tcp_forwarder_listener():

  # Create a TCP server socket.
  tcp_forwarder_sock = listenforconnection(getmyip(), 
    mycontext['listenport_tcp'])
  
  logmsg("Started TCP NAT Forwarder listener on '%s' port '%d'" % 
         (getmyip(), mycontext['listenport_tcp']), INFO_MSG)
         
         
while True:
    
    try:
      # Try to see if there is any connection waiting.
      remote_ip, remote_port, sockobj = tcp_forwarder_sock.getconnection() # XXX Use a timeout socket instead to avoid malicious clients/servers blocking sockets forever
      logmsg("Incoming connection from '%s:%d'" % (remote_ip, remote_port), 
        INFO_MSG)
    except SocketWouldBlockError:
      sleep(SLEEP_TIME)
    except Exception, err:
      logmsg("Error in getconnection: " + str(err), ERR_MSG)
    else:
      logmsg("Got connection from " + str(remote_ip) + ":" + str(remote_port), INFO_MSG)
      try:
        conn_init_message = session.session_recvmessage(sockobj)
        logmsg(str(remote_ip) + ":" + str(remote_port) + " said " + 
          conn_init_message, DEBUG_MSG)
        (conn_type, conn_id) = conn_init_message.split(',')
      except Exception, err: # XXX Likely too broad an except
        logmsg("Error in connection establishment with " + str(remote_ip) + 
          ":" + str(remote_port) + ": " + 
          str(type(err)) + " " + str(err), DEBUG_MSG)
        sockobj.close()
        continue
        
        
        if conn_type == SERVER_REGISTER:
        # This is the case where a new server wants to register to this
        # NAT Forwarder.
          createthread(register_new_server(remote_ip, remote_port, conn_id, sockobj))
          logmsg("Registered server " + remote_ip + ":" + str(remote_port), DEBUG_MSG)
          


          


if callfunc == 'initialize':
  log("Getting an NTP timestamp...\n")
  # Try all UDP ports; ignore TCP time servers.
  for local_port in list(getresources()[0]["messport"]):
    try:
      time.time_updatetime(local_port)
      break
    except:
      continue
  else:
    log("Could not updatetime() on any of the allowed UDP ports. Continuing with time.time_getunixtime = getruntime.\n")
    time.time_getunixtime = getruntime
    
  
  logmsg("Starting TCP relay.", INFO_MSG)
  logmsg("MAX_SERVERS: " + str(MAX_SERVERS) +
    ", MAX_CLIENTS_PER_SERVER: " + str(MAX_CLIENTS_PER_SERVER), INFO_MSG)


  if len(callargs) < 1:
    log("Usage:\n\tpython repy.py restrictionsfile dylink.r2py tcp_relay.r2py TCP_PORT [FORWARDER_KEY]\n") # XXX Allow for port autoconfiguration!
    exitall()

  mycontext['listenport_tcp'] = int(callargs[0])

  if len(callargs) >= 2:
    # Override tcp_relay_common_lib's key
    NAT_FORWARDER_KEY = callargs[1]
    
    myip, myport = getmyip(), mycontext['listenport_tcp']

  (i_can_listen, ignore, ignore) = canilisten.check_specific_port(myport)

  if not i_can_listen:
    logmsg(
"""NOTE WELL: It seems that your node is not able to receive incoming 
connections from the public Internet. This probably leaves the TCP relay 
uncontactable unless you set up port forwarding etc. on your gateway. 
I'll let you proceed regardless. You hopefully know what you do.""", ERR_MSG)

# Launch the TCP Forwarder.
  logmsg("Creating forwarder thread on " + myip + ":" + str(myport), INFO_MSG)
  createthread(tcp_forwarder_listener)
  # XXX Create a status thread to show the contents of the registered_server dict every ten minutes or so.
  # Launch advertiser and advertise this forwarders ip address, tcp port.
  advertise_value = myip + ':' + str(myport)
  logmsg("Starting advertise thread for " + NAT_FORWARDER_KEY + 
    ": " + advertise_value, INFO_MSG)
  advertisepipe.add_to_pipe(NAT_FORWARDER_KEY, advertise_value)
